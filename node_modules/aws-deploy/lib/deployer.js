module.exports = Deployer;

var Promise = require('bluebird') // available from parent's modules
  , util = require('util')
  , ApiGatewayApi = require('./aws/api_gateway_api')
  , LambdaApi = require('./aws/lambda_api')
  , diff = require('fast-json-patch').compare
  , Lambda = require('./lambda')
  , debug = require('debug')('Deployer') // available from parent's modules
  ;


/** 
 * ### .Deployer(config, apiTree)
 *
 * Update AWS Api
 *
 * @api public
 * @param {AwsConfig} config
 * @param {ApiTree} apiTree
 * @returns {Promise}
 *
 */

function Deployer(config, apiTree) {

  var aws = {
    apigw: new ApiGatewayApi(config),
    lambda: new LambdaApi(config),
  }

  var awsRestApi;

  return new Promise(function(resolve, reject) {

    debug('deploying stage: \'%s\', version: %d', apiTree.deploy.stage, apiTree.deploy.version);

    aws.apigw.getRestApis().then(function(APIs) {

      if (!Array.isArray(APIs)) return;

      APIs.forEach(function(api) {
        if (api.name == apiTree.name) awsRestApi = api;
      });

    })

    .then(function() {

      if (awsRestApi) {
        debug('updating name: \'%s\', id: \'%s\'', awsRestApi.name, awsRestApi.id);
        return awsRestApi;
      }

      debug('creating name: \'%s\'', apiTree.name);
      return aws.apigw.createRestApi({
        name: apiTree.name,
        description: apiTree.description,
      });

    })

    .then(function(result) {
      awsRestApi = result;
      apiTree.hidden('_aws', awsRestApi);
    })

    .then(function() {
      return module.exports.updateApiModels(aws, apiTree, awsRestApi);
    })

    .then(function() {
      return module.exports.updateApiResources(aws, apiTree, awsRestApi);
    })

    .then(function(awsRestApi) {
      return module.exports.createApiResources(aws, apiTree, awsRestApi);
    })

    .then(function() {
      return aws.apigw.createRestApiDeployment(apiTree, awsRestApi);
    })


    .then(function(awsRestApiDeployment) {
      apiTree.deployment.url = util.format(
        'https://%s.execute-api.%s.amazonaws.com/%s%s',
        awsRestApi.id,
        apiTree.deploy.region,
        apiTree.deploy.stage,
        apiTree.deploy.version
      );

      apiTree.deployment.hidden('_aws', awsRestApiDeployment);
      apiTree.updated(apiTree.deployment);
    })

    .then(function() {

      // Deploy result contains the input apiTree ammended
      // with deployment details and the corresponding aws
      // object instances.

      resolve(apiTree.sort());

    })

    .catch(reject)

  });
  
}


/**
 * List of AWS api clients
 *
 * @typedef AwsApiList
 * @type {object}
 * @property {ApiGatewayApi} apigw
 * @property {LambdaApi} lambda
 *
 */


/**
 * List of 'methods' associated with an AWS Api Gateway resource
 *
 * @typedef AwsLinkRelations
 * @type {object}
 * @property {{href: string}} self - eg { self: { href: '/restapis/1hjovnyjw0' },
 * @property {{href: string, templated: boolean}} repeating method list - eg {'deployment:create': { href: '/restapis/1hjovnyjw0/deployments' },
 *
 */


/**
 * Instance of an AWS Api Gateway RestApi as returned from AWS
 * 
 * @typedef AwsRestApi
 * @type {object}
 * @property {string} id
 * @property {string} name
 * @property {string} description
 * @property {AwsLinkRelations} _links
 *
 */


/**
 * ### .updateApiModels(aws, apiTree, awsRestApi)
 *
 * Synchronize models from apiTree definition to AWS Api Gateway
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApi} awsRestApi
 * @returns {Promise}
 *
 */


module.exports.updateApiModels = function(aws, apiTree, awsRestApi) {

  var awsModels;
  var models = apiTree.models;
  var done = [];

  return aws.apigw.getRestApiModels(awsRestApi)

  .then(function(result) {

    awsModels = result;

    // Update existing models

    debug('updating %d (existing) model%s', awsModels.length, awsModels.length == 1 ? '' : 's');

    return Promise.map(awsModels, function(awsModel) {

      var model = models[awsModel.name];

      if (!model) {

        // Delete models from AWS that are not in local apiTree

        if (awsModel.name == 'Empty' || awsModel.name == 'Error') {
          //leave default aws models
          return;
        }
        
        return aws.apigw.deleteRestApiModel(awsModel)

        .then(function(result) {

          debug('name: \'%s\' model DELETED', awsModel.name);

        })

      }

      var patch = diff(
        awsModel.excludeKeys([
          'name',
          'id',
          'schema', // diff separately, it's a json string with strange spacing
          '_links',
          '_embedded'
        ]),
        model.excludeKeys([
          '_aws',
          '_log',
          'schema',
        ])
      );

      var patch2 = diff(
        JSON.parse(awsModel.schema),
        model.schema
      );

      if (patch.length == 0 && patch2.length == 0) {
        model.hidden('_aws', awsModel);
        debug('name: \'%s\' model unchanged', awsModel.name);
        done.push(awsModel.name);
        return;
      }

      if (patch2.length > 0) {
        patch.push({
          op: 'replace', path: '/schema', value: JSON.stringify(model.schema, null, 2)
        })
      }

      return aws.apigw.patchRestApiModel(awsModel, patch)

      .then(function(result) {
        awsModel = result;
        model.hidden('_aws', result);
        debug('name: \'%s\' model UPDATED', awsModel.name);
        done.push(awsModel.name);
        apiTree.updated(model);
      })

    })

    .then(function() {

      var newModels = Object.keys(apiTree.models).filter(function(name) {
        return done.indexOf(name) == -1;
      }).map(function(name) {
        apiTree.models[name].name = name;
        return apiTree.models[name];
      });

      debug('creating %d (new) model%s', newModels.length, newModels.length == 1 ? '' : 's');

      return Promise.map(newModels, function(model) {

        // need to collapse the schema into a nested json string

        var props = {};
        for (var key in model) props[key] = model[key];
        props.schema = JSON.stringify(model.schema, null, 2);



        return aws.apigw.createRestApiModel(awsRestApi, props)

        .then(function(awsModel) {

          model.hidden('_aws', awsModel);
          apiTree.updated(model);
          debug('name: \'%s\' model CREATED', awsModel.name);

        })

      })

    })

  })

}


/**
 * ### .updateApiResources(aws, apiTree, api)
 *
 * Updates Api Resources ie. routes
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApi} awsRestApi
 * @returns {Promise}
 *
 */

module.exports.updateApiResources = function(aws, apiTree, awsRestApi) {

  return new Promise(function(resolve, reject) {

    aws.apigw.getRestApiResources({
      id: awsRestApi.id
    })

    .then(function(resources) {

      Object.defineProperty(awsRestApi, 'resources', {value: resources}); // used in createApiResources()

      debug('updating %d (existing) resource%s', resources.length, resources.length !== 1 ? 's' : '');

      // Process reversed so that if deleting any resources it does not
      // delete (eg) '/users' before '/users/{username}/drimbles/{colour}'
      // because that would error.

      var reversed = resources.sort(function(a, b) {
        if (a.path < b.path) return 1;
        if (b.path < a.path) return -1;
        return 0;
      });

      return Promise.map(reversed, function(awsResource) {
        return module.exports.updateApiResource(aws, apiTree, awsRestApi, awsResource);
      });

    })

    .then(function() {

      // Resolve with awsRestApi, for next promise

      resolve(awsRestApi);

    })

    .catch(reject);

  });

}

/**
 * ### .createApiResources(aws, apiTree, awsRestApi)
 *
 * Create Api Resources not already present in awsRestApi
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApi} awsRestApi
 * @returns {Promise}
 *
 */

module.exports.createApiResources = function(aws, apiTree, awsRestApi) {

  return new Promise(function(resolve, reject) {

    // createApiResources('api name: \'%s\'', awsRestApi.name);

    var createResourceSpec = function(path) {

      var pathParts = path.split('/');
      var pathPart = pathParts.pop();
      var parentPath = pathParts.length > 1 ? pathParts.join('/') : '/';

      return {
        path: path,
        pathPart: pathPart,
        parentPath: parentPath,
      }

    }

    var createList = Object.keys(apiTree.routes).filter(function(path) {

      // Filter out resources already present in awsRestApi

      return awsRestApi.resources.filter(function(resource) {
        return path == resource.path;
      }).length == 0;

    }).map(function(path) {

      return createResourceSpec(path);
      
    });

    debug('creating %d (new) resource%s', createList.length, createList.length !== 1 ? 's' : '');

    if (createList.length == 0) return resolve();

    // Need to get fancy because the parent is needed to create the child
    // ie. can't create '/users/{user_id}' without '/users' being created first

    var accumulate = [];

    var recurse = function() {

      var parent, resource = createList.shift();

      if (!resource) {

        // None left in createList, all done. 
        // Update methods for all new resources in accumulated list.

        return Promise.map(accumulate, function(awsResource) {
          return module.exports.updateApiResource(aws, apiTree, awsRestApi, awsResource);
        }).then(resolve).catch(reject);

      }

      parent = apiTree.routes[resource.parentPath];

      // If parent is not defined then requeue resource AND parent, and retry

      if (!parent || !parent._aws) {

        createList.unshift(resource);
        createList.unshift(createResourceSpec(resource.parentPath));
        return recurse();

      }

      debug('path: \'%s\'', resource.path);

      aws.apigw.createRestApiResource({pathPart: resource.pathPart}, parent._aws)

      .then(function(result) {

        // Attach new aws entity to apiTree at resource location

        apiTree.routes[resource.path] = apiTree.routes[resource.path] || {};
        apiTree.routes[resource.path].hidden('_aws', result);

        // Accumulate each created resource for update

        accumulate.push(result);
        recurse();

      })

      .catch(reject);

    }

    recurse()

  });

}


/**
 * Instance of an AWS Api Gateway RestApi resource as returned from AWS
 * 
 * @typedef AwsRestApiResource
 * @type {object}
 * @property {string} id
 * @property {string} parentId
 * @property {string} path
 * @property {string} pathPart
 * @property {AwsLinkRelations} _links
 *
 */


/**
 * ### .updateApiResource(aws, apiTree, awsResource)
 *
 * Updates existing Api Resource ie. route
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApi} awsRestApi
 * @param {AwsRestApiResource} awsResource
 * @returns {Promise}
 * 
 */

module.exports.updateApiResource = function(aws, apiTree, awsRestApi, awsResource) {

  debug('path: \'%s\'', awsResource.path);

  var allMethods = apiTree.getMethods(awsResource.path);

  if (!allMethods) {

    // Can't delete route

    if (awsResource.path == '/') return;

    // getMethods() returns null if the path is not defined in apiTree
    // so here is an awsResource defined in AWS but not in the deploying
    // config, it should be deleted.

    debug('path: \'%s\' DELETED', awsResource.path);

    return aws.apigw.deleteRestApiResource(awsResource)

    .then(function() {

      delete apiTree.routes[awsResource.path];

    })

  }

  // Attach aws entity to apiTree at resource location

  apiTree.routes[awsResource.path] = apiTree.routes[awsResource.path] || {};
  apiTree.routes[awsResource.path].hidden('_aws', awsResource);

  // Delete methods on the awsResource that are not in the deploying config.

  return module.exports.deleteApiResourceMethods(aws, apiTree, awsResource, allMethods)

  .then(function() {

    return Promise.map(allMethods, function(apiMethod) {

      // Update or add methods from deploying config into awsResource

      return module.exports.updateApiResourceMethod(aws, apiTree, awsRestApi, awsResource, apiMethod);

    });

  })

  .then(function() {

    // Mark resource (route) as deployed

    var resource = apiTree.routes[awsResource.path];

    if (!resource._log) return;

    // apiTree.updated(resource);

  });

}


/**
 * ### .deleteApiResourceMethods(aws, apiTree, awsResource)
 *
 * Delete methods from awsResource not present in apiTree
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApiResource} awsResource
 * @param {ApiMethod[]} allMethods
 * @returns {Promise}
 *
 */

module.exports.deleteApiResourceMethods = function(aws, apiTree, awsResource, allMethods) {

  var deleteList;

  try {

    deleteList = awsResource._links['resource:methods'];

    if (deleteList) {

      if (!Array.isArray(deleteList)) deleteList = [deleteList];

      // Filter for awsResource methods that don't exist in apiTree (allMethods)

      deleteList = deleteList.filter(function(method) {
        return allMethods.filter(function(m) {
          return m.method == method.name;
        }).length == 0;
      });

    }

    else deleteList = [];

  } catch (e) {

    debug('awsResource missing _links');
    deleteList = [];

  }

  return Promise.map(deleteList, function(methodLink) {

    return module.exports.deleteApiResourceMethod(aws, awsResource, methodLink)

    .then(function() {

      delete apiTree.routes[awsResource.path][methodLink.name];

    })

  });

}


/**
 * Instance of an AWS Api Gateway RestApi method as returned from AWS
 * 
 * @typedef AwsRestApiMethodLink
 * @type {object}
 * @property {string} href
 * @property {string} name
 * @property {string} title
 *
 */

/**
 * ### .deleteApiResourceMethod(aws, apiTree, awsResource, method)
 *
 * Delete specific method from awsResource
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {AwsRestApiResource} awsResource
 * @param {AwsRestApiMethodLink} method
 * @returns {Promise}
 *
 */

module.exports.deleteApiResourceMethod = function(aws, awsResource, methodLink) {

  debug('method: \'%s\', path: \'%s\' DELETED', methodLink.name, awsResource.path);

  return aws.apigw.deleteRestApiMethod(methodLink)

  .then(function() {

    // Remove method from resource listing

    if (Array.isArray(awsResource._links['resource:methods'])) {

      var remove = awsResource._links['resource:methods'].filter(function(m) {
        return methodLink.href != m.href;
      });

      if (remove.length == 1) awsResource._links['resource:methods'] = remove[0];
      else awsResource._links['resource:methods'] = remove;
    }

    else if (awsResource._links['resource:methods'].href == methodLink.href) {
      delete awsResource._links['resource:methods']
    }

  });

}


/**
 * ### .updateApiResourceMethod(aws, apiTree, awsResource, apiMethod)
 *
 * Update method on the Api Gateway with method from the apiTree
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApi} awsRestApi
 * @param {AwsRestApiResource} awsResource
 * @param {ApiMethod} apiMethod
 * @returns {Promise}
 *
 */

module.exports.updateApiResourceMethod = function(aws, apiTree, awsRestApi, awsResource, apiMethod) {

  var methodLinks = awsResource._links['resource:methods'];
  var methodLink;
  var awsApiMethod;
  var createdMethod = true;

  return new Promise(function(resolve, reject) {

    // create if necessary

    if (!methodLinks) {
      return module.exports.createApiResourceMethod(
        aws, apiTree, awsResource, apiMethod
      ).then(function(result) {
        apiMethod.definition.method.hidden('_aws', result);
        apiTree.updated(apiMethod.definition.method);
        resolve(result);
      }).catch(reject);
    }

    if (!Array.isArray(methodLinks)) {
      if (methodLinks.name != apiMethod.method) {
        return module.exports.createApiResourceMethod(
          aws, apiTree, awsResource, apiMethod
        ).then(function(result) {
          apiMethod.definition.method.hidden('_aws', result);
          apiTree.updated(apiMethod.definition.method);
          resolve(result);
        }).catch(reject);
      }
      methodLink = methodLinks;
    }

    else if (
      methodLinks.filter(function(mlink) {
        if (mlink.name == apiMethod.method) {
          methodLink = mlink;
          return true;
        }
        return false;
      }
    ).length == 0) {
      return module.exports.createApiResourceMethod(
        aws, apiTree, awsResource, apiMethod
      )
      .then(function(result) {
        apiMethod.definition.method.hidden('_aws', result);
        apiTree.updated(apiMethod.definition.method);
        resolve(result);
      }).catch(reject);
    }

    createdMethod = false;
    debug('method: \'%s\', path: \'%s\'', apiMethod.method, awsResource.path);
    resolve();

  })

  .then(function(result) {

    // got created, result is new awsApiMethod
    if (result) return awsApiMethod = result;

    // not created, get awsApiMethod
    return aws.apigw.getRestApiMethod(methodLink)

  })

  .then(function(result) {

    if (createdMethod) return;

    awsApiMethod = result;

    var doUpdate;

    apiMethod.definition.method.hidden('_aws', awsApiMethod);

    var method = apiMethod.definition.method;

    if (!method) return doUpdate = false;

    var changeables = awsApiMethod.excludeKeys([
      '_links',
      '_embedded',
      'httpMethod',
    ]);

    var patch = diff(changeables, method.excludeKeys([
      '_aws',
      '_log',
      'responses',
    ]));

    aws.apigw.removePatchNulls(['/requestModels', '/requestParameters'], patch);

    if (patch.length > 0) return doUpdate = true;

    return doUpdate = false;

  })

  .then(function(doUpdate) {

    if (createdMethod) return;

    if (doUpdate) {

      debug(
        'method: \'%s\', path: \'%s\' method CHANGED', apiMethod.method, awsResource.path
      );

      var method = apiMethod.definition.method;

      return aws.apigw.patchRestApiMethod(method, awsApiMethod, awsResource);
    }

    debug(
      'method: \'%s\', path: \'%s\' method unchanged', apiMethod.method, awsResource.path
    );

  })

  .then(function(updated) {

    if (updated) {
      var method = apiMethod.definition.method;
      apiTree.updated(method);
      apiMethod.definition.method.hidden('_aws', awsApiMethod = updated);
    }

  })

  .then(function() {

    return module.exports.updateApiMethodResponses(aws, apiTree, apiMethod, awsResource, awsApiMethod)

  })

  .then(function() {

    return module.exports.updateApiMethodIntegration(aws, apiTree, apiMethod, awsRestApi, awsResource, awsApiMethod)

  })

  .then(function() {

    // final resolve with the aws rest api instance

    return awsRestApi;

  })

}


/**
 * ### .createApiResourceMethod(aws, apiTree, awsResource, apiMethod)
 *
 * Create method on the Api Gateway with method from the apiTree
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {AwsRestApiResource} awsResource
 * @param {ApiMethod} apiMethod
 * @returns {Promise}
 *
 */

module.exports.createApiResourceMethod = function(aws, apiTree, awsResource, apiMethod) {

  debug('method: \'%s\', path: \'%s\'', apiMethod.method, awsResource.path);

  var definition = apiMethod.definition;
  var method = definition.method;

  var httpMethod = apiMethod.method;
  var awsMethod = {
    authorizationType: method.authorizationType,
    apiKeyRequired: method.apiKeyRequired,
    requestParameters: method.requestParameters,
    requestModels: method.requestModels,
  }

  return aws.apigw.createRestApiMethod(httpMethod, awsMethod, awsResource)

  .then(function(awsMethod) {

    // Add new method to resource listing (messy because it's an array only if more than 1)

    debug('method: \'%s\', path: \'%s\' method CREATED', apiMethod.method, awsResource.path);
    apiTree.updated(method);

    if (Array.isArray(awsResource._links['resource:methods'])) {
      awsResource._links['resource:methods'].push(awsMethod._links.self);
    } else if (typeof awsResource._links['resource:methods'] !== 'undefined') {
      awsResource._links['resource:methods'] = [
        awsResource._links['resource:methods'],
        awsMethod._links.self
      ];
    } else {
      awsResource._links['resource:methods'] = awsMethod._links.self;
    }
    return awsMethod;

  });

}


/**
 * ### .createOrUpdateLambda(aws, apiMethod, awsApiMethod)
 *
 * Create method on the Api Gateway with method from the apiTree
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {ApiMethod} apiMethod
 * @param {AwsRestApiResource} awsResource
 * @param {AwsApiMethod} awsApiMethod
 * @returns {Promise}
 *
 */


module.exports.updateApiMethodResponses = function(aws, apiTree, apiMethod, awsResource, awsApiMethod) {

  // Update exising method responses

  var awsMethodResponses;
  var method = apiMethod.definition.method;
  var responses = method.responses;
  var done = [];

  try {
    awsMethodResponses = awsApiMethod._embedded['method:responses'] || [];
    if (!Array.isArray(awsMethodResponses)) awsMethodResponses = [awsMethodResponses];
  } catch (e) {
    awsMethodResponses = [];
  }

  return Promise.map(awsMethodResponses, function(awsMethodResponse) {

    var statusCode = awsMethodResponse.statusCode;
    var apiMethodResponse = responses[statusCode];

    if (!apiMethodResponse) {

      return aws.apigw.deleteRestApiMethodResponse(awsMethodResponse)

      .then(function() {

        debug(
          'method: \'%s\', path: \'%s\', response: \'%s\' DELETED',
          apiMethod.method,
          awsResource.path,
          statusCode
        );

      });

    }

    var patch = diff(
      awsMethodResponse.excludeKeys([
        'statusCode',
        '_links',
        '_embedded'
      ]),
      apiMethodResponse.excludeKeys([
        '_aws',
        '_log',
      ])
    );

    if (patch.length == 0) {

      done.push(statusCode);
      apiTree.updated(apiMethodResponse);
      return debug(
        'method: \'%s\', path: \'%s\', response: \'%s\' unchanged',
        apiMethod.method,
        awsResource.path,
        statusCode
      );

    }

    return aws.apigw.patchRestApiMethodResponse(awsMethodResponse, patch)

    .then(function(result) {

      done.push(statusCode);
      apiTree.updated(apiMethodResponse);
      return debug(
        'method: \'%s\', path: \'%s\', response: \'%s\' UPDATED',
        apiMethod.method,
        awsResource.path,
        statusCode
      )

    })

  })

  .then(function() {

    // Find methodResponses still to add

    var addList = Object.keys(responses).filter(function(statusCode) {
      return done.indexOf(statusCode) == -1;
    })

    if (addList.length == 0) return;

    return Promise.map(addList, function(statusCode) {

      var apiMethodResponse = responses[statusCode];

      apiMethodResponse.statusCode = statusCode;

      return aws.apigw.createRestApiMethodResponse(apiMethodResponse, awsApiMethod)

      .then(function(result) {
        apiTree.updated(apiMethodResponse);
        return debug(
          'method: \'%s\', path: \'%s\', response: \'%s\' CREATED',
          apiMethod.method,
          awsResource.path,
          statusCode
        );

      })

    })

  })

}


/**
 * ### .updateApiMethodIntegration(aws, apiMethod, awsApiMethod)
 *
 * Create method on the Api Gateway with method from the apiTree
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiTree} apiTree
 * @param {ApiMethod} apiMethod
 * @param {AwsRestApi} awsRestApi
 * @param {AwsRestApiResource} awsResource
 * @param {AwsApiMethod} awsApiMethod
 * @returns {Promise}
 *
 */


module.exports.updateApiMethodIntegration = function(aws, apiTree, apiMethod, awsRestApi, awsResource, awsApiMethod) {

  var integration = apiMethod.definition.integration;
  var awsApiMethodIntegration;
  var awsLambdaFunction;
  var createdIntegration = true;
  var updatedPermission = false;

  return new Promise(function(resolve, reject) {

    try {
      awsApiMethodIntegration = awsApiMethod._embedded['method:integration']
    } catch (e) {}

    if (!integration && awsApiMethodIntegration) {

      return aws.apigw.deleteRestApiMethodIntegration(awsApiMethodIntegration)

      .then(function() {

        debug(
          'method: \'%s\', path: \'%s\' %s integration DELETED',
          apiMethod.method,
          awsResource.path,
          awsApiMethodIntegration.type
        );

      }).catch(reject)

    }

    resolve();

  })

  .then(function() {

    if (!integration) return;
    
    if (integration.lambda) {
      return module.exports.createOrUpdateLambda(aws, apiTree, apiMethod);
    }

  })

  .then(function(result) {

    if (!integration) return;
    
    if (integration.lambda) {

      awsLambdaFunction = result;
      integration.type = 'AWS';
      integration.uri = Lambda.load(integration.lambda, apiTree.deploy).uri;
      integration.httpMethod = awsApiMethod.httpMethod;

    };

    if (!awsApiMethodIntegration) {
      return aws.apigw.createRestApiMethodIntegration(integration, awsApiMethod, awsResource);
    }

    createdIntegration = false;

    var changeables = awsApiMethodIntegration.excludeKeys([
      '_links',
      '_embedded',
      'cacheNamespace', // If we start using the cache, remove this.
      'credentials',
    ]);

    var patch = diff(changeables, integration.excludeKeys([
      'cacheNamespace', // If we start using the cache, remove this.
      'credentials',
      '_aws',
      '_log',
      'lambda',
      '_permission'
    ]));

    aws.apigw.removePatchNulls(['/requestParameters', '/requestTemplates'], patch);

    if (integration.lambda) {
      aws.apigw.removePatchIgnores(['/httpMethod'], patch);
    }

    if (patch.length > 0) {
      return aws.apigw.patchRestApiMethodIntegration(
        integration, awsApiMethodIntegration, awsApiMethod, awsResource
      );
    }

  })

  .then(function(result) {

    if (!integration) return;

    if (result) {
      awsApiMethodIntegration = result;
      integration.hidden('_aws', result);
      apiTree.updated(integration);

      debug(
        'method: \'%s\', path: \'%s\' %s integration %s',
        apiMethod.method,
        awsResource.path,
        result.type,
        createdIntegration ? 'CREATED' : 'UPDATED'
      );
    }

    if (integration.lambda) {

      var lambda = Lambda.load(integration.lambda, apiTree.deploy);

      if (!integration._permission) {
        return aws.lambda.addPermission(lambda, awsRestApi, awsResource, awsApiMethod);
      }

      // Already have assigned permission for this integration, reassign permission if anything changed

      var body = lambda.toAddPermission(awsRestApi, awsResource, awsApiMethod);

      if (body.StatementId != integration._permission.Sid) {

        updatedPermission = true;

        return aws.lambda.removePermission(lambda, integration._permission, awsResource, awsApiMethod)

        .then(function(result) {
          return aws.lambda.addPermission(lambda, awsRestApi, awsResource, awsApiMethod);
        })

        .catch(function(result) {
          return aws.lambda.addPermission(lambda, awsRestApi, awsResource, awsApiMethod);
        })

      }

    }

  })

  .then(function(result) {

    if (!integration) return;

    if (result) {

      debug('method: \'%s\', path: \'%s\' lambda permission %s',
        apiMethod.method, 
        awsResource.path,
        updatedPermission ? 'UPDATED' : 'CREATED'
      )
      integration._permission = JSON.parse(result.Statement);
    }
    else {
      if (integration.lambda) {
        debug('method: \'%s\', path: \'%s\' lambda permission unchanged',
          apiMethod.method,
          awsResource.path
        )
      }
    }

  })

  .then(function() {

    if (!integration) return;

    console.log('TODO: integrationResponses');

  })

}


/**
 * ### .createOrUpdateLambda(aws, apiMethod, awsApiMethod)
 *
 * Create method on the Api Gateway with method from the apiTree
 *
 * @api private
 * @param {AwsApiList} aws
 * @param {ApiMethod} apiMethod
 * @returns {Promise}
 *
 */

module.exports.createOrUpdateLambda = function(aws, apiTree, apiMethod) {

  var integration = apiMethod.definition.integration;
  var lambda = Lambda.load(integration.lambda, apiTree.deploy);
  var awsLambdaFunction;
  var unchanged = true;

  debug('lambda: \'%s\'', lambda.storeFile);

  return new Promise(function(resolve, reject) {

    aws.lambda.getFunction(lambda)

    // Fails 404 if function undefined, proceeds to create below

    .then(function(result) {
      awsLambdaFunction = result;

      var changeables = awsLambdaFunction.Configuration.includeKeys([
        'Description', 'Handler', 'MemorySize', 'Role', 'Timeout'
      ]);

      var patch = diff(changeables, lambda.toUpdateFunctionConfiguration());
      if (patch.length > 0) {
        unchanged = false;
        debug('lambda: \'%s\' UPDATED config \'%j\'', lambda.storeFile, patch);
        return aws.lambda.updateFunctionConfiguration(lambda);
      }

    })

    .then(function(result) {
      var awsLambdaVersion = awsLambdaFunction.Configuration.CodeSha256;
      if (awsLambdaVersion != lambda.sha256) {
        unchanged = false;
        debug('lambda: \'%s\' UPDATED code', lambda.storeFile);
        return aws.lambda.updateFunctionCode(lambda);
      }
    })

    .then(function(result) {
      if (unchanged) {
        debug('lambda: \'%s\' unchanged', lambda.storeFile);
        return resolve(awsLambdaFunction);
      }
      return aws.lambda.getFunction(lambda)
    })

    .then(function(result) {
      awsLambdaFunction = result;
      return resolve(awsLambdaFunction);
    })

    .catch(function(error) {
      if (!error._response) return reject(error);
      if (error._response.statusCode != 404) return reject(error);

      // Got 404, lambda does not exist, create it

      aws.lambda.createFunction(lambda)

      .then(function(result) {
        debug('lambda: \'%s\' CREATED', lambda.storeFile);
        return aws.lambda.getFunction(lambda);
      })

      .then(function(result) {
        awsLambdaFunction = result;
        return resolve(awsLambdaFunction);
      })

      .catch(reject);
      
    })


  });

}

