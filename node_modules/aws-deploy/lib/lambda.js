/**
 * # Lambda
 *
 * Provides the necessary functionality to build a lambda zip file given
 * only the javascript file that defines the lambda
 *
 */


module.exports = Lambda;

var Promise = require('bluebird')
  , fs = require('fs')
  , os = require('os')
  , path = require('path')
  , AdmZip = require('adm-zip')
  , hash = require('hash.js')
  , debug = require('debug')('Lambda')
  ;

// Cache of loaded lambdas

var cache = {};


/**
 * ## load(config, version, deployStage)
 *
 * Loads new or return Lambda instance from cache.
 * 
 * @api public
 * @param {{file: String, handler: String}} config
 * @param {{app: String, version: Number, stage: String, account: Number}} deploy
 *
 */

module.exports.load = function(config, deploy) {

  return cache[config.file] || (cache[config.file] = new Lambda(config, deploy));

}


/**
 * ## Lambda(config, version, deployStage)
 *
 * Lambda instance.
 *
 * @api public
 * @constructor
 * @param {{file: String, handler: String}} config
 * @param {{app: String, version: Number, stage: String, account: Number}} deploy
 *
 */

function Lambda(config, deploy) {

  this.deploy = deploy;
  this.stage = deploy.stage;
  this.stage += '_' + deploy.version;
  this.file = config.file;
  this.config = config;

  // Uploaded lambdas are in a userwide flat list with only names to distinguish them
  // so the name needs to include the stage and the appname

  this.name = this.stage + '--' + deploy.app + '--' + config.file
  .replace(/\./, '_')
  .replace(/\//g, '--')
  .replace(/\\/g, '--')

  debug('create lambda: \'%s\', name: \'%s\', for stage: \'%s\'', this.file, this.name, this.stage);

  Object.defineProperty(this, 'content', {
    value: fs.readFileSync(this.file).toString()
  });

  this.modules = this.content.split(os.EOL) // Windows??

  // remove comments

  .map(function(line) {
    var place = line.indexOf('//');
    if (place < 0) return line;
    return line.substr(0, place);
  })

  // find require("thing") or require('thing')

  .map(function(line) {
    var match = line.match(/require\('(.*)'\)/);
    if (match) return match[1];
    match = line.match(/require\("(.*)"\)/);
    if (match) return match[1];
  })

  // remove where none found on line

  .filter(function(name) {
    return !!name;
  })

  // and filter out ./files and ./dirs

  .filter(function(name) {
    if (name[0] == '.') return false;
    return true;
  })

  // and ensure specified node modules are installed

  .map(function(name) {
    debug('requires module: \'%s\'', name);
    try {
      fs.statSync('node_modules' + path.sep + name)
    } catch (e) {
      throw new Error('missing \'node_modules/' + name + '\' needed by \'' + this.file + '\'');
    }
    return name;
  });

  this.zip();

}


/**
 * ### .toCreateFunction()
 *
 * Returns this lambda as the AWS definition for LambdaApi.createFunction()
 * @api public
 *
 *
 */

Lambda.prototype.toCreateFunction = function() {

  return {
    Code: {
      ZipFile: this.base64
    },
    Description: this.config.Description || '',
    FunctionName: this.name,
    Handler: this.config.Handler || 'index.handler',
    MemorySize: this.config.MemorySize || 128,
    // Publish: true,
    Role: 'arn:aws:iam::'+ this.deploy.account + ':role/' + (this.config.Role || 'lambda_basic_execution'),
    Runtime: 'nodejs',
    Timeout: this.config.Timeout || 3,
  }

}


/**
 * ### .toUpdateFunctionConfiguration()
 *
 * Returns this lambda as the AWS definition for LambdaApi.updateFunctionConfiguration()
 *
 * @api public
 *
 */

Lambda.prototype.toUpdateFunctionConfiguration = function() {

  return {
    // CodeSha256: this.sha256,
    Description: this.config.Description || '', 
    Handler: this.config.Handler || 'index.handler',
    MemorySize: this.config.MemorySize || 128,
    Role: 'arn:aws:iam::'+ this.deploy.account + ':role/' + (this.config.Role || 'lambda_basic_execution'),
    Timeout: this.config.Timeout || 3,
  }

}


/**
 * ### .toUpdateFunctionCode()
 *
 * Returns this lambda as the AWS definition for LambdaApi.toUpdateFunctionCode()
 *
 * @api public
 *
 */

Lambda.prototype.toUpdateFunctionCode = function() {

  return {
    // Publish: true,
    ZipFile: this.base64,
  }

}


/**
 * ### .zip()
 *
 * Zip the lambda files and directories.
 *
 * @api public
 *
 */

Lambda.prototype.zip = function() {

  if (this.base64) {
    debug('already ziped for lambda: ', this.file);
  }

  debug('loading zip for lambda: ', this.file);

  var _this = this;

  var zip = new AdmZip();
  var zipFileName = process.cwd() + path.sep + 'deployed' + path.sep + this.stage + path.sep + _this.file + '.zip'

  // Include modules and api directory

  var directories = this.modules.map(function(name) {
    return process.cwd() + path.sep + 'node_modules' + path.sep + name;
  }).concat(process.cwd() + path.sep + 'api');

  var shasum = this.shasum(directories, zipFileName);

  var buffer, zipshasum;

  if (shasum.unchanged) {

    debug('no changes to zip for lambda: \'%s\'', this.file);
    buffer = fs.readFileSync(zipFileName);
    zipshasum = new Buffer(hash.sha256().update(buffer).digest('base64')).toString('base64')

  }

  else {

    debug('generating new zip for lambda: ', this.file);
    directories.forEach(function(name) {
      var directory = path.relative(process.cwd(), name);
      debug('adding directory: \'%s\'',directory);
      zip.addLocalFolder(directory, directory);
    });

    debug('write %s', path.relative(process.cwd(), zipFileName));
    zip.writeZip(zipFileName);
    debug('write %s', path.relative(process.cwd(), shasum.file));
    fs.writeFileSync(shasum.file, shasum.value);
    buffer = zip.toBuffer();
    zipshasum = new Buffer(hash.sha256().update(buffer).digest('base64')).toString('base64')
    debug('write %s', path.relative(process.cwd(), zipFileName + '.shasum'));
    fs.writeFileSync(zipFileName + '.shasum', zipshasum);
    debug('write %s', path.relative(process.cwd(), zipFileName + '.name'));
    fs.writeFileSync(zipFileName + '.name', this.name);

  }

  Object.defineProperty(_this, 'base64', {
    value: buffer.toString('base64')
  });

  Object.defineProperty(_this, 'sha256', {
    value: zipshasum
  });

}


/**
 * ### .shasum(directories, zipFileName);
 *
 * shasum of all files in directories concatenated was written
 * to zipFileName.content.sha254 when the zip was saved.
 * 
 * compare and return changed-ness
 *
 * Because zip files don't preserve checksum and there is a need
 * to know if a new zip needs to be uploaded.
 *
 * @api public
 * @param {String[]} directories
 * @param {String} zipFileName
 * @returns {null|shasum}
 *
 */

Lambda.prototype.shasum = function(directories, zipFileName) {

  // TODO: this needs to be async, so zip() also needs to be async

  var previous, shasum, content = '', files = [];
  var storeFile = zipFileName + '.content.sha256'

  try {
    previous = fs.readFileSync(storeFile);
  } catch (e) {}

  var recurse = function(next, collect) {
    var stat, list;
    try {
      stat = fs.statSync(next);
    } catch (e) {
      console.log(e);
      return;
    }
    if (!stat.isDirectory()) {
      return collect.push(next);
    }
    try {
      list = fs.readdirSync(next);
    } catch (e) {
      return;
    }
    list.forEach(function(subthing) {
      recurse(next + path.sep + subthing, collect);
    });

  }

  directories.forEach(function(dirname) {
    recurse(dirname, files);
  });

  files.forEach(function(filename) {
    content += fs.readFileSync(filename).toString();
  });

  shasum = new Buffer(hash.sha256().update(content).digest('base64')).toString('base64');

  return {
    unchanged: previous == shasum,
    value: shasum,
    file: storeFile
  }

}



