module.exports = ApiTree;

var ApiHandler = require('./api_handler');


/**
 * ### ApiTree(tree)
 *
 * Api definition tree
 *
 * @constructor
 * @api private
 * @param {Object} tree
 *
 */

function ApiTree(tree) {

  this.name = tree.name;
  this.description = tree.description;

  Object.defineProperty(this, '_root', {value: this.buildTree(tree.routes)});

  this.setDeployStatus();

  console.log(JSON.stringify(this._root, null, 2));

}


/**
 * ### .getHandlers(path)
 *
 * Get route handler definition
 *
 * @api public
 * @param {String} path
 * @returns {ApiHandler[]}
 *
 */

ApiTree.prototype.getHandlers = function(path) {

  var pathArray = path.split('/');

  pathArray.shift();

  var walk = function(remainingPath, pointer) {
    var next;
    if (!pointer) return;
    if (next = remainingPath.shift()) return walk(remainingPath, pointer[next]);
    return pointer;
  }

  var def = walk(pathArray, this._root);

  if (!def) return;

  // Return empty in case where route is present but without methods
  // Important because null handlers are deleted,
  // but empty [] handlers may have children.

  if (!def._methods) return [];

  return Object.keys(def._methods).map(function(method) {

    return new ApiHandler({
      path: path,
      method: method,
      definition: def._methods[method]
    });

  });

}

/**
 * ### .buildTree(tree)
 *
 * Builds tree from flat definition of routes
 *
 * @api private
 * @param {Object} flatTree
 * @returns {Object}
 *
 */

ApiTree.prototype.buildTree = function(flatTree) {

  var tree = {};

  var createRecursive = function(remainingPath, pointer, methods) {

    var next, fixed;

    if (next = remainingPath.shift()) {

      if (next.match(/^:/)) {
        next = next.replace(/^:/, '{') + '}';
      }

      pointer[next] = pointer[next] || {};
      return createRecursive(remainingPath, pointer[next], methods);

    }

    pointer._methods = methods;
    
  }

  Object.keys(flatTree).forEach(function(path) {

    var methods = flatTree[path];
    var pathArray = path.split('/');

    pathArray.shift(); // toss the bit before ''/ the slash

    if (pathArray[0] == '' && methods) return tree._methods = methods;

    createRecursive(pathArray, tree, methods);

  });

  console.log(tree);

  return tree;


}


/**
 * ### .setDeployStatus(tree)
 *
 * Set status object onto each handler method. Used by deploy to determine actions.
 *
 * @api private
 *
 */

ApiTree.prototype.setDeployStatus = function() {

  var recurse = function(pointer) {

    // mark as deployed or not

    pointer._deploy = pointer._deploy || {};
    pointer._deploy.done = typeof pointer._deploy.done == 'boolean' ? pointer._deploy.done : false;

    // also mark each method

    if (pointer._methods) {
      Object.keys(pointer._methods).forEach(function(method) {

        var def = pointer._methods[method];
        def._deploy = def._deploy || {};
        def._deploy.done = typeof def._deploy.done == 'boolean' ? def._deploy.done : false;

      });
    }

    Object.keys(pointer).forEach(function(pathPart) {

      if (pathPart == '_methods') return;
      if (pathPart == '_deploy') return;
      recurse(pointer[pathPart]);

    });

  }

  recurse(this._root);

}

