module.exports = ApiTree;

var ApiTreeDefaults = require('./api_tree_defaults');
var ApiMethod = require('./api_method');
var httpMethods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT'];


/**
 * ### ApiTree(tree)
 *
 * Api definition tree
 *
 * @constructor
 * @api private
 * @param {{deploy_stage: String}} config
 * @param {Object} tree
 * @param {Object} deployRecord - saved apiTree with accumulated results from previous deploys
 *
 */

function ApiTree(config, tree, deployRecord) {

  this.version = tree.version;
  this.name = tree.name;
  this.description = tree.description;
  this.routes = tree.routes;

  Object.defineProperty(this, 'deploy', {
    value: {
      app: this.name.replace(/\s/g, '-').toLowerCase(),
      version: this.version,
      stage: config.deploy_stage, 
      account: config.aws_account,
    }
  });

  this.validate();
  this.loadDefaults();
  this.setDeployStatus(deployRecord);

}


/**
 * ### .validate()
 *
 * @api public
 *
 */

ApiTree.prototype.validate = function() {
  for (var path in this.routes) {
    if (path.lastChar == '/') throw new Error('invalid ' + path);
  }
}


/**
 * ### .getMethods(path)
 *
 * Get route handler definition
 *
 * @api public
 * @param {String} path
 * @returns {ApiMethod[]}
 *
 */

ApiTree.prototype.getMethods = function(path) {

  if (!this.routes[path]) {

    // Returning null means resource will be deleted at AWS Api Gateway
    // so if this path is not specifically defined but forms the parent
    // of some other path, retun empty list of methods

    if (this.isParentRoute(path)) return [];

    return;
  }

  var route = this.routes[path];

  return httpMethods.filter(function(method) {

    return !!route[method];

  }).map(function(method) {

    return new ApiMethod({
      path: path,
      method: method,
      definition: route[method]
    });

  });

}


/**
 * ### .updated(obj, event)
 *
 * Set _log.updated
 *
 */

ApiTree.prototype.updated = function(obj) {
  obj._log = obj._log || {};
  obj._log[(obj._log.created ? 'updated' : 'created')] = {
    at: new Date()
  }
}


/**
 * ### .isParentRoute(path)
 *
 * Is parent of some other route
 *
 * ie.   /users is parent of /users/username/glimph
 *
 */

ApiTree.prototype.isParentRoute = function(path) {
  for (var route in this.routes) {
    if (route.indexOf(path) == 0) return true;
  }
  return false;
}


/**
 * ### .sort()
 *
 * Rearrange route entry contents to put /
 *
 * @api private
 *
 */

ApiTree.prototype.sort = function() {

  var sorted = {}
  var routes = this.routes;

  Object.keys(this.routes).sort(function(a, b) {
    if (a < b) return -1;
    if (b < a) return 1;
    return 0;
  }).forEach(function(route) {
    sorted[route] = routes[route];
  });

  this.routes = sorted;
  return this;

}


/**
 * ### .loadDefaults()
 *
 * @api private
 *
 */

ApiTree.prototype.loadDefaults = function() {

  var _this = this;
  Object.keys(this.routes).forEach(function(path) {

    var routeHandlers = _this.routes[path];

    httpMethods.forEach(function(httpMethod) {

      var handler = routeHandlers[httpMethod];

      if (!handler) return;

      ApiTreeDefaults.load('method', handler, {path: path});
      ApiTreeDefaults.load('integration', handler);

    });

  });

}


/**
 * ### .setDeployStatus(deployRecord)
 *
 * Load record from previous deployment into this deployment
 * to preserve history.
 *
 * @api private
 * @params {Object} deployRecord
 *
 */

ApiTree.prototype.setDeployStatus = function(deployRecord) {

  var _this = this;
  Object.keys(this.routes).forEach(function(path) {

    var definition = _this.routes[path];

    httpMethods.forEach(function(httpMethod) {

      if (!definition[httpMethod]) return;

      ['method', 'integration'].forEach(function(name) {

        var thing = definition[httpMethod][name];
        var record;

        try {
          record = deployRecord.routes[path][httpMethod][name];
        } catch (e) {}
        thing._log = thing._log || {};

        if (record && record._log) {
          Object.keys(record._log).forEach(function(key) {
            thing._log[key] = record._log[key];
          });
        }

        // thing._log.done = false; // set back to true after the run

      });

    });

  });

}

