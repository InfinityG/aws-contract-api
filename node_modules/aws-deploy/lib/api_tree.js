module.exports = ApiTree;

var ApiTreeDefaults = require('./api_tree_defaults');
var ApiMethod = require('./api_method');
var httpMethods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT'];


/**
 * ### ApiTree(tree)
 *
 * Api definition tree
 *
 * @typedef ApiDeployment TODO
 * @typedef ApiModels TODO
 * @typedef ApiRoutes TODO
 *
 * @constructor
 * @api private
 * @param {{deploy_stage: String, aws_account: String, aws_region: String}} config
 * @param {{version: Number: name: String, description: String, deployment: ApiDeployment, models: ApiModels, routes: ApiRoutes}} tree
 * @param {ApiTree} deployRecord - saved apiTree with accumulated results from previous deploy.
 *
 */

function ApiTree(config, tree, deployRecord) {

  this.version = tree.version;
  this.name = tree.name;
  this.description = tree.description;

  this.deployment = {
    url: 'pending',
    stageName: 'pending',
  }

  for (var key in tree.deployment) {
    if (key == 'url') return;
    this.deployment[key] = tree.deployment[key];
  }

  this.models = tree.models;
  for (var modelname in tree.models) {
    var schema = {
      $schema: 'http://json-schema.org/draft-04/schema#'
    }
    var existing = tree.models[modelname].schema || {};
    for (var key in existing) {
      schema[key] = existing[key];
    }
    this.models[modelname].schema = schema;
  }

  this.routes = tree.routes;

  Object.defineProperty(this, 'deploy', {
    value: {
      app: this.name.replace(/\s/g, '-').toLowerCase(),
      version: this.version,
      stage: config.deploy_stage, 
      account: config.aws_account,
      region: config.aws_region,
    }
  });

  this.validate();
  this.loadDefaults();
  this.setDeployStatus(deployRecord);

}


/**
 * ### .validate()
 *
 * @api public
 *
 */

ApiTree.prototype.validate = function() {
  for (var path in this.routes) {
    if (path.lastChar == '/') throw new Error('invalid ' + path);
  }
}


/**
 * ### .getMethods(path)
 *
 * Get route handler definition
 *
 * @api public
 * @param {String} path
 * @returns {ApiMethod[]}
 *
 */

ApiTree.prototype.getMethods = function(path) {

  if (!this.routes[path]) {

    // Returning null means resource will be deleted at AWS Api Gateway
    // so if this path is not specifically defined but forms the parent
    // of some other path, retun empty list of methods

    if (path == '/') return [];

    if (this.isParentRoute(path)) return [];

    return;
  }

  var route = this.routes[path];

  return httpMethods.filter(function(method) {

    return !!route[method];

  }).map(function(method) {

    return new ApiMethod({
      path: path,
      method: method,
      definition: route[method]
    });

  });

}


/**
 * ### .updated(obj, event)
 *
 * Set _log.updated
 *
 */

ApiTree.prototype.updated = function(obj) {
  obj._log = obj._log || {};
  obj._log[(obj._log.created ? 'updated' : 'created')] = {
    at: new Date()
  }
}


/**
 * ### .isParentRoute(path)
 *
 * Is parent of some other route
 *
 * ie.   /users is parent of /users/username/glimph
 * but.  /use   in not parent of /users
 *
 */

ApiTree.prototype.isParentRoute = function(path) {
  for (var route in this.routes) {
    if (route.indexOf(path) == 0) {
      var remains = route.replace(new RegExp('^' + path), '');
      if (remains[0] == '/') return true;
    }
  }
  return false;
}


/**
 * ### .sort()
 *
 * Rearrange route entry contents to put /
 *
 * @api private
 *
 */

ApiTree.prototype.sort = function() {

  var sorted = {}
  var routes = this.routes;

  Object.keys(this.routes).sort(function(a, b) {
    if (a < b) return -1;
    if (b < a) return 1;
    return 0;
  }).forEach(function(route) {
    sorted[route] = routes[route];
  });

  this.routes = sorted;
  return this;

}


/**
 * ### .loadDefaults()
 *
 * @api private
 *
 */

ApiTree.prototype.loadDefaults = function() {

  var _this = this;
  Object.keys(this.routes).forEach(function(path) {

    var routeHandlers = _this.routes[path];

    httpMethods.forEach(function(httpMethod) {

      var handler = routeHandlers[httpMethod];

      if (!handler) return;

      ApiTreeDefaults.load('method', handler, {path: path});
      ApiTreeDefaults.load('integration', handler);

    });

  });

}


/**
 * ### .setDeployStatus(deployRecord)
 *
 * Load record from previous deployment into this deployment
 * to preserve history.
 *
 * @api private
 * @params {Object} deployRecord
 *
 */

ApiTree.prototype.setDeployStatus = function(deployRecord) {

  var _this = this;

  try {
    this.deployment._log = deployRecord.deployment._log;
  } catch (e) {
    // new, no previous deploy record
  }

  Object.keys(this.models).forEach(function(name) {

    var definition = _this.models[name];

    try {
      definition._log = deployRecord.models[name]._log;
    } catch (e) {
      // new, no previous deploy record
    }

  });

  Object.keys(this.routes).forEach(function(path) {

    var definition = _this.routes[path];

    httpMethods.forEach(function(httpMethod) {

      if (!definition[httpMethod]) return;

      ['method', 'integration'].forEach(function(name) {

        var thing = definition[httpMethod][name];
        var record;

        try {
          record = deployRecord.routes[path][httpMethod][name];
        } catch (e) {}
        thing._log = thing._log || {};

        if (record && record._log) {
          Object.keys(record._log).forEach(function(key) {
            thing._log[key] = record._log[key];
          });
        }

        if (record && record._permission) thing._permission = record._permission;

        // thing._log.done = false; // set back to true after the run

      });

    });

  });

}

